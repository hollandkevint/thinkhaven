---
phase: 02-beta-access-control
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/web/lib/auth/jwt-verify.ts
  - apps/web/lib/auth/beta-access.ts
  - apps/web/app/app/layout.tsx
autonomous: true

user_setup:
  - service: supabase
    why: "JWT verification requires secret"
    env_vars:
      - name: SUPABASE_JWT_SECRET
        source: "Supabase Dashboard -> Project Settings -> API -> JWT Secret (under 'JWT Settings')"

must_haves:
  truths:
    - "checkBetaAccess() returns user info and beta approval status"
    - "Unapproved authenticated user visiting /app/* is redirected to /waitlist"
    - "Approved authenticated user can access /app/* normally"
    - "Unauthenticated user visiting /app/* is redirected to /login"
  artifacts:
    - path: "apps/web/lib/auth/jwt-verify.ts"
      provides: "JWT verification utility using jose"
      exports: ["verifyJwt", "JwtPayload"]
    - path: "apps/web/lib/auth/beta-access.ts"
      provides: "Beta access check utility"
      exports: ["checkBetaAccess", "BetaAccessResult"]
    - path: "apps/web/app/app/layout.tsx"
      provides: "Protected app layout with beta gate"
      contains: "checkBetaAccess"
  key_links:
    - from: "apps/web/app/app/layout.tsx"
      to: "checkBetaAccess"
      via: "import and await call"
      pattern: "await checkBetaAccess"
    - from: "apps/web/lib/auth/beta-access.ts"
      to: "verifyJwt"
      via: "import and call with access_token"
      pattern: "verifyJwt.*access_token"
---

<objective>
Create the JWT verification utilities and wire them into the /app/* layout to gate access based on beta approval status. This converts the existing client-side auth check to a server-side beta access gate.

Purpose: Without server-side verification, beta gating can be bypassed. This plan implements the security layer.
Output: Working beta access check that redirects unapproved users to /waitlist.
</objective>

<execution_context>
@/Users/kthkellogg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kthkellogg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-beta-access-control/02-RESEARCH.md
@.planning/phases/02-beta-access-control/02-01-SUMMARY.md
@apps/web/lib/supabase/server.ts
@apps/web/lib/auth/AuthContext.tsx
@apps/web/app/app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JWT verification utility</name>
  <files>apps/web/lib/auth/jwt-verify.ts</files>
  <action>
Create a new file that exports JWT verification functions using the jose library.

```typescript
import { jwtVerify, type JWTPayload } from 'jose';

export interface JwtPayload extends JWTPayload {
  sub: string;
  email?: string;
  beta_approved?: boolean;
}

export async function verifyJwt(token: string): Promise<JwtPayload | null> {
  const secret = process.env.SUPABASE_JWT_SECRET;

  if (!secret) {
    console.error('SUPABASE_JWT_SECRET not configured');
    return null;
  }

  try {
    const encodedSecret = new TextEncoder().encode(secret);
    const { payload } = await jwtVerify(token, encodedSecret);
    return payload as JwtPayload;
  } catch (error) {
    console.error('JWT verification failed:', error);
    return null;
  }
}
```

Key points:
- Use jose's jwtVerify (NOT jsonwebtoken)
- Encode secret with TextEncoder (jose requirement)
- Return null on any verification failure (don't throw)
- Export JwtPayload type for use in beta-access.ts
- Include beta_approved as optional boolean in payload type
  </action>
  <verify>
File exists and TypeScript compiles: `cd apps/web && npx tsc --noEmit lib/auth/jwt-verify.ts 2>&1 | head -5`
If no output, compilation succeeded.
  </verify>
  <done>jwt-verify.ts exports verifyJwt function that validates JWT signature and returns typed payload.</done>
</task>

<task type="auto">
  <name>Task 2: Create beta access check utility</name>
  <files>apps/web/lib/auth/beta-access.ts</files>
  <action>
Create a utility that combines Supabase session retrieval with JWT verification to determine beta access.

```typescript
import { createClient } from '@/lib/supabase/server';
import { verifyJwt, type JwtPayload } from './jwt-verify';

export interface BetaAccessResult {
  user: { id: string; email?: string } | null;
  betaApproved: boolean;
  error: string | null;
}

export async function checkBetaAccess(): Promise<BetaAccessResult> {
  const supabase = await createClient();

  // Get session which contains the access_token
  const { data: { session }, error: sessionError } = await supabase.auth.getSession();

  if (sessionError || !session?.access_token) {
    return { user: null, betaApproved: false, error: 'No session' };
  }

  // Verify JWT and extract claims
  const payload = await verifyJwt(session.access_token);

  if (!payload) {
    return { user: null, betaApproved: false, error: 'Invalid token' };
  }

  return {
    user: { id: payload.sub, email: payload.email },
    betaApproved: payload.beta_approved === true,
    error: null
  };
}
```

Key points:
- Use getSession() to get the access_token (this is safe because we then verify it with jose)
- Call verifyJwt to cryptographically verify the token and extract claims
- Return structured result with user, betaApproved, and error
- Default betaApproved to false if claim is missing or not exactly true
  </action>
  <verify>
File exists and TypeScript compiles: `cd apps/web && npx tsc --noEmit lib/auth/beta-access.ts 2>&1 | head -5`
  </verify>
  <done>beta-access.ts exports checkBetaAccess() that returns user info and beta approval status.</done>
</task>

<task type="auto">
  <name>Task 3: Convert app layout to server component with beta gate</name>
  <files>apps/web/app/app/layout.tsx</files>
  <action>
Convert the existing client component layout to a server component that checks beta access.

The current layout is a 'use client' component that uses useAuth() hook and client-side redirect.
Convert it to a server component that:

1. Remove 'use client' directive
2. Import checkBetaAccess from lib/auth/beta-access
3. Import redirect from next/navigation
4. Make the function async
5. Call checkBetaAccess() and handle three cases:
   - No user: redirect to /login with redirect param
   - User but not approved: redirect to /waitlist
   - Approved user: render children

```typescript
import { redirect } from 'next/navigation';
import { checkBetaAccess } from '@/lib/auth/beta-access';

export default async function AppLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const { user, betaApproved, error } = await checkBetaAccess();

  // Not authenticated
  if (!user || error) {
    redirect('/login?redirect=' + encodeURIComponent('/app'));
  }

  // Authenticated but not approved for beta
  if (!betaApproved) {
    redirect('/waitlist');
  }

  // Approved - render the app
  return <>{children}</>;
}
```

Key points:
- This is now a SERVER component (no 'use client')
- Server-side redirect happens before any HTML is sent
- No loading state needed - redirects are instant from server
- Per Phase 1 decision: NO redirect logic in middleware, but server components can redirect
  </action>
  <verify>
1. File does NOT contain 'use client' directive
2. File imports checkBetaAccess from '@/lib/auth/beta-access'
3. File imports redirect from 'next/navigation'
4. Function is async: `grep "async function AppLayout" apps/web/app/app/layout.tsx`
5. TypeScript compiles: `cd apps/web && npx tsc --noEmit app/app/layout.tsx 2>&1 | head -5`
  </verify>
  <done>App layout is a server component that checks beta access and redirects unapproved users to /waitlist.</done>
</task>

</tasks>

<verification>
1. All three files exist:
   - `ls apps/web/lib/auth/jwt-verify.ts`
   - `ls apps/web/lib/auth/beta-access.ts`
   - `ls apps/web/app/app/layout.tsx`

2. TypeScript compiles without errors:
   - `cd apps/web && npx tsc --noEmit`

3. Layout is server component (no 'use client'):
   - `head -1 apps/web/app/app/layout.tsx` should NOT show 'use client'

4. Layout calls checkBetaAccess:
   - `grep "checkBetaAccess" apps/web/app/app/layout.tsx`
</verification>

<success_criteria>
- jwt-verify.ts exports verifyJwt and JwtPayload
- beta-access.ts exports checkBetaAccess and BetaAccessResult
- app/layout.tsx is a server component that redirects unapproved users to /waitlist
- No TypeScript compilation errors
- Pattern: authentication check happens server-side before any client code runs
</success_criteria>

<output>
After completion, create `.planning/phases/02-beta-access-control/02-02-SUMMARY.md`
</output>
